"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7555],{62731:(t,e,r)=>{let i,n,s;r.d(e,{Vr:()=>tu});var o=r(49641).Buffer;let f=(()=>{let t=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype),Symbol.toStringTag).get;return e=>t.call(e)})();function u(t){return"Uint8Array"===f(t)}function a(t){return"object"==typeof t&&null!=t&&Symbol.toStringTag in t&&("ArrayBuffer"===t[Symbol.toStringTag]||"SharedArrayBuffer"===t[Symbol.toStringTag])}function l(t){return t instanceof RegExp||"[object RegExp]"===Object.prototype.toString.call(t)}function h(t){return"object"==typeof t&&null!=t&&Symbol.toStringTag in t&&"Map"===t[Symbol.toStringTag]}function g(t){return t instanceof Date||"[object Date]"===Object.prototype.toString.call(t)}function m(t,e){return JSON.stringify(t,(t,e)=>"bigint"==typeof e?{$numberLong:`${e}`}:h(e)?Object.fromEntries(e):e)}let b=Symbol.for("@@mdb.bson.version"),c=0x8000000000000000-1;Object.freeze({double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127});class d extends Error{get bsonError(){return!0}get name(){return"BSONError"}constructor(t,e){super(t,e)}static isBSONError(t){return null!=t&&"object"==typeof t&&"bsonError"in t&&!0===t.bsonError&&"name"in t&&"message"in t&&"stack"in t}}class p extends d{get name(){return"BSONVersionError"}constructor(){super("Unsupported BSON version, bson types must be from bson 6.x.x")}}class y extends d{get name(){return"BSONRuntimeError"}constructor(t){super(t)}}class w extends d{get name(){return"BSONOffsetError"}constructor(t,e,r){super(`${t}. offset: ${e}`,r),this.offset=e}}function S(t,e,r,s){if(s){i??=new TextDecoder("utf8",{fatal:!0});try{return i.decode(t.subarray(e,r))}catch(t){throw new d("Invalid UTF-8 string in BSON document",{cause:t})}}return(n??=new TextDecoder("utf8",{fatal:!1})).decode(t.subarray(e,r))}function x(t,e,r){if(0===t.length)return"";let i=r-e;if(0===i)return"";if(i>20)return null;if(1===i&&t[e]<128)return String.fromCharCode(t[e]);if(2===i&&t[e]<128&&t[e+1]<128)return String.fromCharCode(t[e])+String.fromCharCode(t[e+1]);if(3===i&&t[e]<128&&t[e+1]<128&&t[e+2]<128)return String.fromCharCode(t[e])+String.fromCharCode(t[e+1])+String.fromCharCode(t[e+2]);let n=[];for(let i=e;i<r;i++){let e=t[i];if(e>127)return null;n.push(e)}return String.fromCharCode(...n)}let N={toLocalBufferType(t){if(o.isBuffer(t))return t;if(ArrayBuffer.isView(t))return o.from(t.buffer,t.byteOffset,t.byteLength);let e=t?.[Symbol.toStringTag]??Object.prototype.toString.call(t);if("ArrayBuffer"===e||"SharedArrayBuffer"===e||"[object ArrayBuffer]"===e||"[object SharedArrayBuffer]"===e)return o.from(t);throw new d("Cannot create Buffer from the passed potentialBuffer.")},allocate:t=>o.alloc(t),allocateUnsafe:t=>o.allocUnsafe(t),equals:(t,e)=>N.toLocalBufferType(t).equals(e),fromNumberArray:t=>o.from(t),fromBase64:t=>o.from(t,"base64"),toBase64:t=>N.toLocalBufferType(t).toString("base64"),fromISO88591:t=>o.from(t,"binary"),toISO88591:t=>N.toLocalBufferType(t).toString("binary"),fromHex:t=>o.from(t,"hex"),toHex:t=>N.toLocalBufferType(t).toString("hex"),toUTF8(t,e,r,i){let n=r-e<=20?x(t,e,r):null;if(null!=n)return n;let s=N.toLocalBufferType(t).toString("utf8",e,r);if(i){for(let i=0;i<s.length;i++)if(65533===s.charCodeAt(i)){S(t,e,r,!0);break}}return s},utf8ByteLength:t=>o.byteLength(t,"utf8"),encodeUTF8Into(t,e,r){let i=function(t,e,r){if(0===e.length)return 0;if(e.length>25||t.length-r<e.length)return null;for(let i=0,n=r;i<e.length;i++,n++){let r=e.charCodeAt(i);if(r>127)return null;t[n]=r}return e.length}(t,e,r);return null!=i?i:N.toLocalBufferType(t).write(e,r,void 0,"utf8")},randomBytes:function(t){return N.fromNumberArray(Array.from({length:t},()=>Math.floor(256*Math.random())))},swap32:t=>N.toLocalBufferType(t).swap32()};function E(t){if(t<0)throw RangeError(`The argument 'byteLength' is invalid. Received ${t}`);return $.fromNumberArray(Array.from({length:t},()=>Math.floor(256*Math.random())))}let B=(()=>{let{crypto:t}=globalThis;if(null!=t&&"function"==typeof t.getRandomValues)return e=>t.getRandomValues($.allocate(e));if(function(){let{navigator:t}=globalThis;return"object"==typeof t&&"ReactNative"===t.product}()){let{console:t}=globalThis;t?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.")}return E})(),O=/(\d|[a-f])/i,$={toLocalBufferType(t){let e=t?.[Symbol.toStringTag]??Object.prototype.toString.call(t);if("Uint8Array"===e)return t;if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength));if("ArrayBuffer"===e||"SharedArrayBuffer"===e||"[object ArrayBuffer]"===e||"[object SharedArrayBuffer]"===e)return new Uint8Array(t);throw new d("Cannot make a Uint8Array from passed potentialBuffer.")},allocate(t){if("number"!=typeof t)throw TypeError(`The "size" argument must be of type number. Received ${String(t)}`);return new Uint8Array(t)},allocateUnsafe:t=>$.allocate(t),equals(t,e){if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},fromNumberArray:t=>Uint8Array.from(t),fromBase64:t=>Uint8Array.from(atob(t),t=>t.charCodeAt(0)),toBase64:t=>btoa($.toISO88591(t)),fromISO88591:t=>Uint8Array.from(t,t=>255&t.charCodeAt(0)),toISO88591:t=>Array.from(Uint16Array.from(t),t=>String.fromCharCode(t)).join(""),fromHex(t){let e=t.length%2==0?t:t.slice(0,t.length-1),r=[];for(let t=0;t<e.length;t+=2){let i=e[t],n=e[t+1];if(!O.test(i)||!O.test(n))break;let s=Number.parseInt(`${i}${n}`,16);r.push(s)}return Uint8Array.from(r)},toHex:t=>Array.from(t,t=>t.toString(16).padStart(2,"0")).join(""),toUTF8(t,e,r,i){let n=r-e<=20?x(t,e,r):null;return null!=n?n:S(t,e,r,i)},utf8ByteLength:t=>new TextEncoder().encode(t).byteLength,encodeUTF8Into(t,e,r){let i=new TextEncoder().encode(e);return t.set(i,r),i.byteLength},randomBytes:B,swap32(t){if(t.length%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(let e=0;e<t.length;e+=4){let r=t[e],i=t[e+1],n=t[e+2],s=t[e+3];t[e]=s,t[e+1]=n,t[e+2]=i,t[e+3]=r}return t}},I="function"==typeof o&&o.prototype?._isBuffer!==!0?N:$;class _{get[b](){return 6}[Symbol.for("nodejs.util.inspect.custom")](t,e,r){return this.inspect(t,e,r)}}let U=new Float64Array(1),T=new Uint8Array(U.buffer,0,8);U[0]=-1;let v=0===T[7],L={isBigEndian:v,getNonnegativeInt32LE(t,e){if(t[e+3]>127)throw RangeError(`Size cannot be negative at offset: ${e}`);return t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24},getInt32LE:(t,e)=>t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24,getUint32LE:(t,e)=>t[e]+256*t[e+1]+65536*t[e+2]+0x1000000*t[e+3],getUint32BE:(t,e)=>t[e+3]+256*t[e+2]+65536*t[e+1]+0x1000000*t[e],getBigInt64LE(t,e){let r=BigInt(t[e+4]+256*t[e+5]+65536*t[e+6]+(t[e+7]<<24)),i=BigInt(t[e]+256*t[e+1]+65536*t[e+2]+0x1000000*t[e+3]);return(r<<BigInt(32))+i},getFloat64LE:v?(t,e)=>(T[7]=t[e],T[6]=t[e+1],T[5]=t[e+2],T[4]=t[e+3],T[3]=t[e+4],T[2]=t[e+5],T[1]=t[e+6],T[0]=t[e+7],U[0]):(t,e)=>(T[0]=t[e],T[1]=t[e+1],T[2]=t[e+2],T[3]=t[e+3],T[4]=t[e+4],T[5]=t[e+5],T[6]=t[e+6],T[7]=t[e+7],U[0]),setInt32BE:(t,e,r)=>(t[e+3]=r,r>>>=8,t[e+2]=r,r>>>=8,t[e+1]=r,r>>>=8,t[e]=r,4),setInt32LE:(t,e,r)=>(t[e]=r,r>>>=8,t[e+1]=r,r>>>=8,t[e+2]=r,r>>>=8,t[e+3]=r,4),setBigInt64LE(t,e,r){let i=BigInt(0xffffffff),n=Number(r&i);t[e]=n,n>>=8,t[e+1]=n,n>>=8,t[e+2]=n,n>>=8,t[e+3]=n;let s=Number(r>>BigInt(32)&i);return t[e+4]=s,s>>=8,t[e+5]=s,s>>=8,t[e+6]=s,s>>=8,t[e+7]=s,8},setFloat64LE:v?(t,e,r)=>(U[0]=r,t[e]=T[7],t[e+1]=T[6],t[e+2]=T[5],t[e+3]=T[4],t[e+4]=T[3],t[e+5]=T[2],t[e+6]=T[1],t[e+7]=T[0],8):(t,e,r)=>(U[0]=r,t[e]=T[0],t[e+1]=T[1],t[e+2]=T[2],t[e+3]=T[3],t[e+4]=T[4],t[e+5]=T[5],t[e+6]=T[6],t[e+7]=T[7],8)};class A extends _{get _bsontype(){return"Binary"}constructor(t,e){if(super(),null!=t&&"string"==typeof t&&!ArrayBuffer.isView(t)&&!a(t)&&!Array.isArray(t))throw new d("Binary can only be constructed from Uint8Array or number[]");this.sub_type=e??A.BSON_BINARY_SUBTYPE_DEFAULT,null==t?(this.buffer=I.allocate(A.BUFFER_SIZE),this.position=0):(this.buffer=Array.isArray(t)?I.fromNumberArray(t):I.toLocalBufferType(t),this.position=this.buffer.byteLength)}put(t){let e;if("string"==typeof t&&1!==t.length)throw new d("only accepts single character String");if("number"!=typeof t&&1!==t.length)throw new d("only accepts single character Uint8Array or Array");if((e="string"==typeof t?t.charCodeAt(0):"number"==typeof t?t:t[0])<0||e>255)throw new d("only accepts number in a valid unsigned byte range 0-255");if(this.buffer.byteLength>this.position)this.buffer[this.position++]=e;else{let t=I.allocate(A.BUFFER_SIZE+this.buffer.length);t.set(this.buffer,0),this.buffer=t,this.buffer[this.position++]=e}}write(t,e){if(e="number"==typeof e?e:this.position,this.buffer.byteLength<e+t.length){let e=I.allocate(this.buffer.byteLength+t.length);e.set(this.buffer,0),this.buffer=e}if(ArrayBuffer.isView(t))this.buffer.set(I.toLocalBufferType(t),e),this.position=e+t.byteLength>this.position?e+t.length:this.position;else if("string"==typeof t)throw new d("input cannot be string")}read(t,e){let r=t+(e=e&&e>0?e:this.position);return this.buffer.subarray(t,r>this.position?this.position:r)}value(){return this.buffer.length===this.position?this.buffer:this.buffer.subarray(0,this.position)}length(){return this.position}toJSON(){return I.toBase64(this.buffer.subarray(0,this.position))}toString(t){return"hex"===t?I.toHex(this.buffer.subarray(0,this.position)):"base64"===t?I.toBase64(this.buffer.subarray(0,this.position)):I.toUTF8(this.buffer,0,this.position,!1)}toExtendedJSON(t){t=t||{},this.sub_type===A.SUBTYPE_VECTOR&&j(this);let e=I.toBase64(this.buffer),r=Number(this.sub_type).toString(16);return t.legacy?{$binary:e,$type:1===r.length?"0"+r:r}:{$binary:{base64:e,subType:1===r.length?"0"+r:r}}}toUUID(){if(this.sub_type===A.SUBTYPE_UUID)return new D(this.buffer.subarray(0,this.position));throw new d(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${A.SUBTYPE_UUID}" is currently supported.`)}static createFromHexString(t,e){return new A(I.fromHex(t),e)}static createFromBase64(t,e){return new A(I.fromBase64(t),e)}static fromExtendedJSON(t,e){let r,i;if(e=e||{},"$binary"in t?e.legacy&&"string"==typeof t.$binary&&"$type"in t?(i=t.$type?parseInt(t.$type,16):0,r=I.fromBase64(t.$binary)):"string"!=typeof t.$binary&&(i=t.$binary.subType?parseInt(t.$binary.subType,16):0,r=I.fromBase64(t.$binary.base64)):"$uuid"in t&&(i=4,r=D.bytesFromString(t.$uuid)),!r)throw new d(`Unexpected Binary Extended JSON format ${JSON.stringify(t)}`);return 4===i?new D(r):new A(r,i)}inspect(t,e,r){r??=m;let i=I.toBase64(this.buffer.subarray(0,this.position)),n=r(i,e),s=r(this.sub_type,e);return`Binary.createFromBase64(${n}, ${s})`}toInt8Array(){if(this.sub_type!==A.SUBTYPE_VECTOR)throw new d("Binary sub_type is not Vector");if(this.buffer[0]!==A.VECTOR_TYPE.Int8)throw new d("Binary datatype field is not Int8");return j(this),new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset+2,this.buffer.byteOffset+this.position))}toFloat32Array(){if(this.sub_type!==A.SUBTYPE_VECTOR)throw new d("Binary sub_type is not Vector");if(this.buffer[0]!==A.VECTOR_TYPE.Float32)throw new d("Binary datatype field is not Float32");j(this);let t=new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset+2,this.buffer.byteOffset+this.position));return L.isBigEndian&&I.swap32(t),new Float32Array(t.buffer)}toPackedBits(){if(this.sub_type!==A.SUBTYPE_VECTOR)throw new d("Binary sub_type is not Vector");if(this.buffer[0]!==A.VECTOR_TYPE.PackedBit)throw new d("Binary datatype field is not packed bit");return j(this),new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset+2,this.buffer.byteOffset+this.position))}toBits(){if(this.sub_type!==A.SUBTYPE_VECTOR)throw new d("Binary sub_type is not Vector");if(this.buffer[0]!==A.VECTOR_TYPE.PackedBit)throw new d("Binary datatype field is not packed bit");j(this);let t=new Int8Array(8*(this.length()-2)-this.buffer[1]);for(let e=0;e<t.length;e++){let r=e/8|0,i=this.buffer[r+2]>>7-e%8&1;t[e]=i}return t}static fromInt8Array(t){let e=I.allocate(t.byteLength+2);e[0]=A.VECTOR_TYPE.Int8,e[1]=0;let r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e.set(r,2);let i=new this(e,this.SUBTYPE_VECTOR);return j(i),i}static fromFloat32Array(t){let e=I.allocate(t.byteLength+2);e[0]=A.VECTOR_TYPE.Float32,e[1]=0;let r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e.set(r,2),L.isBigEndian&&I.swap32(new Uint8Array(e.buffer,2));let i=new this(e,this.SUBTYPE_VECTOR);return j(i),i}static fromPackedBits(t,e=0){let r=I.allocate(t.byteLength+2);r[0]=A.VECTOR_TYPE.PackedBit,r[1]=e,r.set(t,2);let i=new this(r,this.SUBTYPE_VECTOR);return j(i),i}static fromBits(t){let e=new Uint8Array((t.length+7>>>3)+2);e[0]=A.VECTOR_TYPE.PackedBit;let r=t.length%8;e[1]=0===r?0:8-r;for(let r=0;r<t.length;r++){let i=r>>>3,n=t[r];if(0!==n&&1!==n)throw new d(`Invalid bit value at ${r}: must be 0 or 1, found ${t[r]}`);if(0===n)continue;let s=7-r%8;e[i+2]|=n<<s}return new this(e,A.SUBTYPE_VECTOR)}}function j(t){if(t.sub_type!==A.SUBTYPE_VECTOR)return;let e=t.position,r=t.buffer[0],i=t.buffer[1];if((r===A.VECTOR_TYPE.Float32||r===A.VECTOR_TYPE.Int8)&&0!==i)throw new d("Invalid Vector: padding must be zero for int8 and float32 vectors");if(r===A.VECTOR_TYPE.Float32&&0!==e&&e-2!=0&&(e-2)%4!=0)throw new d("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");if(r===A.VECTOR_TYPE.PackedBit&&0!==i&&2===e)throw new d("Invalid Vector: padding must be zero for packed bit vectors that are empty");if(r===A.VECTOR_TYPE.PackedBit&&i>7)throw new d(`Invalid Vector: padding must be a value between 0 and 7. found: ${i}`)}A.BSON_BINARY_SUBTYPE_DEFAULT=0,A.BUFFER_SIZE=256,A.SUBTYPE_DEFAULT=0,A.SUBTYPE_FUNCTION=1,A.SUBTYPE_BYTE_ARRAY=2,A.SUBTYPE_UUID_OLD=3,A.SUBTYPE_UUID=4,A.SUBTYPE_MD5=5,A.SUBTYPE_ENCRYPTED=6,A.SUBTYPE_COLUMN=7,A.SUBTYPE_SENSITIVE=8,A.SUBTYPE_VECTOR=9,A.SUBTYPE_USER_DEFINED=128,A.VECTOR_TYPE=Object.freeze({Int8:3,Float32:39,PackedBit:16});let R=/^[0-9A-F]{32}$/i,V=/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;class D extends A{constructor(t){let e;if(null==t)e=D.generate();else if(t instanceof D)e=I.toLocalBufferType(new Uint8Array(t.buffer));else if(ArrayBuffer.isView(t)&&16===t.byteLength)e=I.toLocalBufferType(t);else if("string"==typeof t)e=D.bytesFromString(t);else throw new d("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");super(e,4)}get id(){return this.buffer}set id(t){this.buffer=t}toHexString(t=!0){return t?[I.toHex(this.buffer.subarray(0,4)),I.toHex(this.buffer.subarray(4,6)),I.toHex(this.buffer.subarray(6,8)),I.toHex(this.buffer.subarray(8,10)),I.toHex(this.buffer.subarray(10,16))].join("-"):I.toHex(this.buffer)}toString(t){return"hex"===t?I.toHex(this.id):"base64"===t?I.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}equals(t){if(!t)return!1;if(t instanceof D)return I.equals(t.id,this.id);try{return I.equals(new D(t).id,this.id)}catch{return!1}}toBinary(){return new A(this.id,A.SUBTYPE_UUID)}static generate(){let t=I.randomBytes(16);return t[6]=15&t[6]|64,t[8]=63&t[8]|128,t}static isValid(t){return!!t&&("string"==typeof t?D.isValidUUIDString(t):u(t)?16===t.byteLength:"Binary"===t._bsontype&&t.sub_type===this.SUBTYPE_UUID&&16===t.buffer.byteLength)}static createFromHexString(t){let e=D.bytesFromString(t);return new D(e)}static createFromBase64(t){return new D(I.fromBase64(t))}static bytesFromString(t){if(!D.isValidUUIDString(t))throw new d("UUID string representation must be 32 hex digits or canonical hyphenated representation");return I.fromHex(t.replace(/-/g,""))}static isValidUUIDString(t){return R.test(t)||V.test(t)}inspect(t,e,r){return r??=m,`new UUID(${r(this.toHexString(),e)})`}}class C extends _{get _bsontype(){return"Code"}constructor(t,e){super(),this.code=t.toString(),this.scope=e??null}toJSON(){return null!=this.scope?{code:this.code,scope:this.scope}:{code:this.code}}toExtendedJSON(){return this.scope?{$code:this.code,$scope:this.scope}:{$code:this.code}}static fromExtendedJSON(t){return new C(t.$code,t.$scope)}inspect(t,e,r){let i=(r??=m)(this.code,e),n=i.includes("\n");null!=this.scope&&(i+=`,${n?"\n":" "}${r(this.scope,e)}`);let s=n&&null===this.scope;return`new Code(${n?"\n":""}${i}${s?"\n":""})`}}function P(t){return null!=t&&"object"==typeof t&&"$id"in t&&null!=t.$id&&"$ref"in t&&"string"==typeof t.$ref&&(!("$db"in t)||"$db"in t&&"string"==typeof t.$db)}class J extends _{get _bsontype(){return"DBRef"}constructor(t,e,r,i){super();let n=t.split(".");2===n.length&&(r=n.shift(),t=n.shift()),this.collection=t,this.oid=e,this.db=r,this.fields=i||{}}get namespace(){return this.collection}set namespace(t){this.collection=t}toJSON(){let t=Object.assign({$ref:this.collection,$id:this.oid},this.fields);return null!=this.db&&(t.$db=this.db),t}toExtendedJSON(t){t=t||{};let e={$ref:this.collection,$id:this.oid};return t.legacy?e:(this.db&&(e.$db=this.db),e=Object.assign(e,this.fields))}static fromExtendedJSON(t){let e=Object.assign({},t);return delete e.$ref,delete e.$id,delete e.$db,new J(t.$ref,t.$id,t.$db,e)}inspect(t,e,r){let i=[(r??=m)(this.namespace,e),r(this.oid,e),...this.db?[r(this.db,e)]:[],...Object.keys(this.fields).length>0?[r(this.fields,e)]:[]];return i[1]=r===m?`new ObjectId(${i[1]})`:i[1],`new DBRef(${i.join(", ")})`}}function F(t){if(""===t)return t;let e=0,r="-"===t[0],i="+"===t[e];(i||r)&&(e+=1);let n=!1;for(;e<t.length&&"0"===t[e];++e)n=!0;return n?`${r?"-":""}${t.length===e?"0":t.slice(e)}`:i?t.slice(1):t}try{s=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}let M={},H={},Y=/^(\+?0|(\+|-)?[1-9][0-9]*)$/;class q extends _{get _bsontype(){return"Long"}get __isLong__(){return!0}constructor(t=0,e,r){super();let i="boolean"==typeof e?e:!!r,n="string"==typeof t?q.fromString(t,i):"bigint"==typeof t?q.fromBigInt(t,i):{low:0|t,high:0|("number"==typeof e?e:0),unsigned:i};this.low=n.low,this.high=n.high,this.unsigned=n.unsigned}static fromBits(t,e,r){return new q(t,e,r)}static fromInt(t,e){let r,i,n;if(e)return(t>>>=0,(n=0<=t&&t<256)&&(i=H[t]))?i:(r=q.fromBits(t,(0|t)<0?-1:0,!0),n&&(H[t]=r),r);return(t|=0,(n=-128<=t&&t<128)&&(i=M[t]))?i:(r=q.fromBits(t,t<0?-1:0,!1),n&&(M[t]=r),r)}static fromNumber(t,e){if(isNaN(t))return e?q.UZERO:q.ZERO;if(e){if(t<0)return q.UZERO;if(t>=0xffffffffffffffff)return q.MAX_UNSIGNED_VALUE}else{if(t<=-0x8000000000000000)return q.MIN_VALUE;if(t+1>=0x8000000000000000)return q.MAX_VALUE}return t<0?q.fromNumber(-t,e).neg():q.fromBits(t%0x100000000|0,t/0x100000000|0,e)}static fromBigInt(t,e){let r=BigInt(0xffffffff),i=BigInt(32);return new q(Number(t&r),Number(t>>i&r),e)}static _fromString(t,e,r){let i;if(0===t.length)throw new d("empty string");if(r<2||36<r)throw new d("radix");if((i=t.indexOf("-"))>0)throw new d("interior hyphen");if(0===i)return q._fromString(t.substring(1),e,r).neg();let n=q.fromNumber(Math.pow(r,8)),s=q.ZERO;for(let e=0;e<t.length;e+=8){let i=Math.min(8,t.length-e),o=parseInt(t.substring(e,e+i),r);if(i<8){let t=q.fromNumber(Math.pow(r,i));s=s.mul(t).add(q.fromNumber(o))}else s=(s=s.mul(n)).add(q.fromNumber(o))}return s.unsigned=e,s}static fromStringStrict(t,e,r){let i=!1;if("number"==typeof e?(r=e,e=!1):i=!!e,r??=10,t.trim()!==t)throw new d(`Input: '${t}' contains leading and/or trailing whitespace`);if(!function(t,e){e=e??10;let r="0123456789abcdefghijklmnopqrstuvwxyz".slice(0,e);return!RegExp(`[^-+${r}]`,"i").test(t)&&t}(t,r))throw new d(`Input: '${t}' contains invalid characters for radix: ${r}`);let n=F(t),s=q._fromString(n,i,r);if(s.toString(r).toLowerCase()!==n.toLowerCase())throw new d(`Input: ${t} is not representable as ${s.unsigned?"an unsigned":"a signed"} 64-bit Long ${null!=r?`with radix: ${r}`:""}`);return s}static fromString(t,e,r){let i=!1;return("number"==typeof e?(r=e,e=!1):i=!!e,r??=10,"NaN"===t&&r<24||("Infinity"===t||"+Infinity"===t||"-Infinity"===t)&&r<35)?q.ZERO:q._fromString(t,i,r)}static fromBytes(t,e,r){return r?q.fromBytesLE(t,e):q.fromBytesBE(t,e)}static fromBytesLE(t,e){return new q(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)}static fromBytesBE(t,e){return new q(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}static isLong(t){return null!=t&&"object"==typeof t&&"__isLong__"in t&&!0===t.__isLong__}static fromValue(t,e){return"number"==typeof t?q.fromNumber(t,e):"string"==typeof t?q.fromString(t,e):q.fromBits(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}add(t){q.isLong(t)||(t=q.fromValue(t));let e=this.high>>>16,r=65535&this.high,i=this.low>>>16,n=65535&this.low,s=t.high>>>16,o=65535&t.high,f=t.low>>>16,u=65535&t.low,a=0,l=0,h,g;return h=0+((g=0+(n+u))>>>16),g&=65535,h+=i+f,l+=h>>>16,h&=65535,l+=r+o,a+=l>>>16,l&=65535,a+=e+s,a&=65535,q.fromBits(h<<16|g,a<<16|l,this.unsigned)}and(t){return q.isLong(t)||(t=q.fromValue(t)),q.fromBits(this.low&t.low,this.high&t.high,this.unsigned)}compare(t){if(q.isLong(t)||(t=q.fromValue(t)),this.eq(t))return 0;let e=this.isNegative(),r=t.isNegative();return e&&!r?-1:!e&&r?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1}comp(t){return this.compare(t)}divide(t){let e,r,i;if(q.isLong(t)||(t=q.fromValue(t)),t.isZero())throw new d("division by zero");if(s){if(!this.unsigned&&-0x80000000===this.high&&-1===t.low&&-1===t.high)return this;let e=(this.unsigned?s.div_u:s.div_s)(this.low,this.high,t.low,t.high);return q.fromBits(e,s.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?q.UZERO:q.ZERO;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return q.UZERO;if(t.gt(this.shru(1)))return q.UONE;i=q.UZERO}else{if(this.eq(q.MIN_VALUE))if(t.eq(q.ONE)||t.eq(q.NEG_ONE))return q.MIN_VALUE;else return t.eq(q.MIN_VALUE)?q.ONE:(e=this.shr(1).div(t).shl(1)).eq(q.ZERO)?t.isNegative()?q.ONE:q.NEG_ONE:(r=this.sub(t.mul(e)),i=e.add(r.div(t)));if(t.eq(q.MIN_VALUE))return this.unsigned?q.UZERO:q.ZERO;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=q.ZERO}for(r=this;r.gte(t);){let n=Math.ceil(Math.log(e=Math.max(1,Math.floor(r.toNumber()/t.toNumber())))/Math.LN2),s=n<=48?1:Math.pow(2,n-48),o=q.fromNumber(e),f=o.mul(t);for(;f.isNegative()||f.gt(r);)e-=s,f=(o=q.fromNumber(e,this.unsigned)).mul(t);o.isZero()&&(o=q.ONE),i=i.add(o),r=r.sub(f)}return i}div(t){return this.divide(t)}equals(t){return q.isLong(t)||(t=q.fromValue(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low}eq(t){return this.equals(t)}getHighBits(){return this.high}getHighBitsUnsigned(){return this.high>>>0}getLowBits(){return this.low}getLowBitsUnsigned(){return this.low>>>0}getNumBitsAbs(){let t;if(this.isNegative())return this.eq(q.MIN_VALUE)?64:this.neg().getNumBitsAbs();let e=0!==this.high?this.high:this.low;for(t=31;t>0&&(e&1<<t)==0;t--);return 0!==this.high?t+33:t+1}greaterThan(t){return this.comp(t)>0}gt(t){return this.greaterThan(t)}greaterThanOrEqual(t){return this.comp(t)>=0}gte(t){return this.greaterThanOrEqual(t)}ge(t){return this.greaterThanOrEqual(t)}isEven(){return(1&this.low)==0}isNegative(){return!this.unsigned&&this.high<0}isOdd(){return(1&this.low)==1}isPositive(){return this.unsigned||this.high>=0}isZero(){return 0===this.high&&0===this.low}lessThan(t){return 0>this.comp(t)}lt(t){return this.lessThan(t)}lessThanOrEqual(t){return 0>=this.comp(t)}lte(t){return this.lessThanOrEqual(t)}modulo(t){if(q.isLong(t)||(t=q.fromValue(t)),s){let e=(this.unsigned?s.rem_u:s.rem_s)(this.low,this.high,t.low,t.high);return q.fromBits(e,s.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))}mod(t){return this.modulo(t)}rem(t){return this.modulo(t)}multiply(t){if(this.isZero())return q.ZERO;if(q.isLong(t)||(t=q.fromValue(t)),s){let e=s.mul(this.low,this.high,t.low,t.high);return q.fromBits(e,s.get_high(),this.unsigned)}if(t.isZero())return q.ZERO;if(this.eq(q.MIN_VALUE))return t.isOdd()?q.MIN_VALUE:q.ZERO;if(t.eq(q.MIN_VALUE))return this.isOdd()?q.MIN_VALUE:q.ZERO;if(this.isNegative())if(t.isNegative())return this.neg().mul(t.neg());else return this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(q.TWO_PWR_24)&&t.lt(q.TWO_PWR_24))return q.fromNumber(this.toNumber()*t.toNumber(),this.unsigned);let e=this.high>>>16,r=65535&this.high,i=this.low>>>16,n=65535&this.low,o=t.high>>>16,f=65535&t.high,u=t.low>>>16,a=65535&t.low,l=0,h=0,g,m;return g=0+((m=0+n*a)>>>16),m&=65535,g+=i*a,h+=g>>>16,g&=65535,g+=n*u,h+=g>>>16,g&=65535,h+=r*a,l+=h>>>16,h&=65535,h+=i*u,l+=h>>>16,h&=65535,h+=n*f,l+=h>>>16,h&=65535,l+=e*a+r*u+i*f+n*o,l&=65535,q.fromBits(g<<16|m,l<<16|h,this.unsigned)}mul(t){return this.multiply(t)}negate(){return!this.unsigned&&this.eq(q.MIN_VALUE)?q.MIN_VALUE:this.not().add(q.ONE)}neg(){return this.negate()}not(){return q.fromBits(~this.low,~this.high,this.unsigned)}notEquals(t){return!this.equals(t)}neq(t){return this.notEquals(t)}ne(t){return this.notEquals(t)}or(t){return q.isLong(t)||(t=q.fromValue(t)),q.fromBits(this.low|t.low,this.high|t.high,this.unsigned)}shiftLeft(t){return(q.isLong(t)&&(t=t.toInt()),0==(t&=63))?this:t<32?q.fromBits(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):q.fromBits(0,this.low<<t-32,this.unsigned)}shl(t){return this.shiftLeft(t)}shiftRight(t){return(q.isLong(t)&&(t=t.toInt()),0==(t&=63))?this:t<32?q.fromBits(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):q.fromBits(this.high>>t-32,this.high>=0?0:-1,this.unsigned)}shr(t){return this.shiftRight(t)}shiftRightUnsigned(t){if(q.isLong(t)&&(t=t.toInt()),0==(t&=63))return this;{let e=this.high;if(t<32){let r=this.low;return q.fromBits(r>>>t|e<<32-t,e>>>t,this.unsigned)}return 32===t?q.fromBits(e,0,this.unsigned):q.fromBits(e>>>t-32,0,this.unsigned)}}shr_u(t){return this.shiftRightUnsigned(t)}shru(t){return this.shiftRightUnsigned(t)}subtract(t){return q.isLong(t)||(t=q.fromValue(t)),this.add(t.neg())}sub(t){return this.subtract(t)}toInt(){return this.unsigned?this.low>>>0:this.low}toNumber(){return this.unsigned?(this.high>>>0)*0x100000000+(this.low>>>0):0x100000000*this.high+(this.low>>>0)}toBigInt(){return BigInt(this.toString())}toBytes(t){return t?this.toBytesLE():this.toBytesBE()}toBytesLE(){let t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]}toBytesBE(){let t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]}toSigned(){return this.unsigned?q.fromBits(this.low,this.high,!1):this}toString(t){if((t=t||10)<2||36<t)throw new d("radix");if(this.isZero())return"0";if(this.isNegative())if(!this.eq(q.MIN_VALUE))return"-"+this.neg().toString(t);else{let e=q.fromNumber(t),r=this.div(e),i=r.mul(e).sub(this);return r.toString(t)+i.toInt().toString(t)}let e=q.fromNumber(Math.pow(t,6),this.unsigned),r=this,i="";for(;;){let n=r.div(e),s=(r.sub(n.mul(e)).toInt()>>>0).toString(t);if((r=n).isZero())return s+i;for(;s.length<6;)s="0"+s;i=""+s+i}}toUnsigned(){return this.unsigned?this:q.fromBits(this.low,this.high,!0)}xor(t){return q.isLong(t)||(t=q.fromValue(t)),q.fromBits(this.low^t.low,this.high^t.high,this.unsigned)}eqz(){return this.isZero()}le(t){return this.lessThanOrEqual(t)}toExtendedJSON(t){return t&&t.relaxed?this.toNumber():{$numberLong:this.toString()}}static fromExtendedJSON(t,e){let{useBigInt64:r=!1,relaxed:i=!0}={...e};if(t.$numberLong.length>20)throw new d("$numberLong string is too long");if(!Y.test(t.$numberLong))throw new d(`$numberLong string "${t.$numberLong}" is in an invalid format`);if(r)return BigInt.asIntN(64,BigInt(t.$numberLong));let n=q.fromString(t.$numberLong);return i?n.toNumber():n}inspect(t,e,r){let i=(r??=m)(this.toString(),e),n=this.unsigned?`, ${r(this.unsigned,e)}`:"";return`new Long(${i}${n})`}}q.TWO_PWR_24=q.fromInt(0x1000000),q.MAX_UNSIGNED_VALUE=q.fromBits(-1,-1,!0),q.ZERO=q.fromInt(0),q.UZERO=q.fromInt(0,!0),q.ONE=q.fromInt(1),q.UONE=q.fromInt(1,!0),q.NEG_ONE=q.fromInt(-1),q.MAX_VALUE=q.fromBits(-1,0x7fffffff,!1),q.MIN_VALUE=q.fromBits(0,-0x80000000,!1);let k=/^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/,Z=/^(\+|-)?(Infinity|inf)$/i,z=/^(\+|-)?NaN$/i,K=I.fromNumberArray([124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),W=I.fromNumberArray([248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),G=I.fromNumberArray([120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),X=/^([-+])?(\d+)?$/;function Q(t){return!isNaN(parseInt(t,10))}function tt(t,e){throw new d(`"${t}" is not a valid Decimal128 string - ${e}`)}class te extends _{get _bsontype(){return"Decimal128"}constructor(t){if(super(),"string"==typeof t)this.bytes=te.fromString(t).bytes;else if(t instanceof Uint8Array||u(t)){if(16!==t.byteLength)throw new d("Decimal128 must take a Buffer of 16 bytes");this.bytes=t}else throw new d("Decimal128 must take a Buffer or string")}static fromString(t){return te._fromString(t,{allowRounding:!1})}static fromStringWithRounding(t){return te._fromString(t,{allowRounding:!0})}static _fromString(t,e){let r=!1,i=!1,n=!1,s=!1,o=0,f=0,u=0,a=0,l=0,h=[0],g=0,m=0,b=0,c=0,p=new q(0,0),y=new q(0,0),w=0,S=0;if(t.length>=7e3)throw new d(""+t+" not a valid Decimal128 string");let x=t.match(k),N=t.match(Z),E=t.match(z);if(!x&&!N&&!E||0===t.length)throw new d(""+t+" not a valid Decimal128 string");if(x){let e=x[2],r=x[4],i=x[5],n=x[6];r&&void 0===n&&tt(t,"missing exponent power"),r&&void 0===e&&tt(t,"missing exponent base"),void 0===r&&(i||n)&&tt(t,"missing e before exponent")}if(("+"===t[S]||"-"===t[S])&&(i=!0,r="-"===t[S++]),!Q(t[S])&&"."!==t[S]){if("i"===t[S]||"I"===t[S])return new te(r?W:G);else if("N"===t[S])return new te(K)}for(;Q(t[S])||"."===t[S];){if("."===t[S]){n&&tt(t,"contains multiple periods"),n=!0,S+=1;continue}g<34&&("0"!==t[S]||s)&&(s||(l=f),s=!0,h[m++]=parseInt(t[S],10),g+=1),s&&(u+=1),n&&(a+=1),f+=1,S+=1}if(n&&!f)throw new d(""+t+" not a valid Decimal128 string");if("e"===t[S]||"E"===t[S]){let e=t.substr(++S).match(X);if(!e||!e[2])return new te(K);c=parseInt(e[0],10),S+=e[0].length}if(t[S])return new te(K);if(g){if(b=g-1,1!==(o=u))for(;"0"===t[l+o-1+Number(i)+Number(n)];)o-=1}else h[0]=0,u=1,g=1,o=0;for(c<=a&&a>c+16384?c=-6176:c-=a;c>6111;){if((b+=1)>=34){if(0===o){c=6111;break}tt(t,"overflow")}c-=1}if(e.allowRounding){for(;c<-6176||g<u;){if(0===b&&o<g){c=-6176,o=0;break}if(g<u?u-=1:b-=1,c<6111)c+=1;else{if(h.join("").match(/^0+$/)){c=6111;break}tt(t,"overflow")}}if(b+1<o){let e=f;n&&(l+=1,e+=1),i&&(l+=1,e+=1);let s=parseInt(t[l+b+1],10),o=0;if(s>=5&&(o=1,5===s)){o=+(h[b]%2==1);for(let r=l+b+2;r<e;r++)if(parseInt(t[r],10)){o=1;break}}if(o){let t=b;for(;t>=0;t--)if(++h[t]>9){if(h[t]=0,0===t)if(!(c<6111))return new te(r?W:G);else c+=1,h[t]=1}else break}}}else{for(;c<-6176||g<u;){if(0===b){if(0===o){c=-6176;break}tt(t,"exponent underflow")}g<u?("0"!==t[u-1+Number(i)+Number(n)]&&0!==o&&tt(t,"inexact rounding"),u-=1):(0!==h[b]&&tt(t,"inexact rounding"),b-=1),c<6111?c+=1:tt(t,"overflow")}b+1<o&&(n&&(l+=1),i&&(l+=1),0!==parseInt(t[l+b+1],10)&&tt(t,"inexact rounding"))}if(p=q.fromNumber(0),y=q.fromNumber(0),0===o)p=q.fromNumber(0),y=q.fromNumber(0);else if(b<17){let t=0;for(y=q.fromNumber(h[t++]),p=new q(0,0);t<=b;t++)y=(y=y.multiply(q.fromNumber(10))).add(q.fromNumber(h[t]))}else{let t=0;for(p=q.fromNumber(h[t++]);t<=b-17;t++)p=(p=p.multiply(q.fromNumber(10))).add(q.fromNumber(h[t]));for(y=q.fromNumber(h[t++]);t<=b;t++)y=(y=y.multiply(q.fromNumber(10))).add(q.fromNumber(h[t]))}let B=function(t,e){if(!t&&!e)return{high:q.fromNumber(0),low:q.fromNumber(0)};let r=t.shiftRightUnsigned(32),i=new q(t.getLowBits(),0),n=e.shiftRightUnsigned(32),s=new q(e.getLowBits(),0),o=r.multiply(n),f=r.multiply(s),u=i.multiply(n),a=i.multiply(s);return o=o.add(f.shiftRightUnsigned(32)),f=new q(f.getLowBits(),0).add(u).add(a.shiftRightUnsigned(32)),{high:o=o.add(f.shiftRightUnsigned(32)),low:a=f.shiftLeft(32).add(new q(a.getLowBits(),0))}}(p,q.fromString("100000000000000000"));B.low=B.low.add(y),function(t,e){let r=t.high>>>0,i=e.high>>>0;if(r<i)return!0;if(r===i&&t.low>>>0<e.low>>>0)return!0;return!1}(B.low,y)&&(B.high=B.high.add(q.fromNumber(1))),w=c+6176;let O={low:q.fromNumber(0),high:q.fromNumber(0)};B.high.shiftRightUnsigned(49).and(q.fromNumber(1)).equals(q.fromNumber(1))?(O.high=O.high.or(q.fromNumber(3).shiftLeft(61)),O.high=O.high.or(q.fromNumber(w).and(q.fromNumber(16383).shiftLeft(47))),O.high=O.high.or(B.high.and(q.fromNumber(0x7fffffffffff)))):(O.high=O.high.or(q.fromNumber(16383&w).shiftLeft(49)),O.high=O.high.or(B.high.and(q.fromNumber(0x1ffffffffffff)))),O.low=B.low,r&&(O.high=O.high.or(q.fromString("9223372036854775808")));let $=I.allocateUnsafe(16);return S=0,$[S++]=255&O.low.low,$[S++]=O.low.low>>8&255,$[S++]=O.low.low>>16&255,$[S++]=O.low.low>>24&255,$[S++]=255&O.low.high,$[S++]=O.low.high>>8&255,$[S++]=O.low.high>>16&255,$[S++]=O.low.high>>24&255,$[S++]=255&O.high.low,$[S++]=O.high.low>>8&255,$[S++]=O.high.low>>16&255,$[S++]=O.high.low>>24&255,$[S++]=255&O.high.high,$[S++]=O.high.high>>8&255,$[S++]=O.high.high>>16&255,$[S++]=O.high.high>>24&255,new te($)}toString(){let t,e,r,i,n=0,s=Array(36);for(let t=0;t<s.length;t++)s[t]=0;let o=0,f=!1,u={parts:[0,0,0,0]},a=[];o=0;let l=this.bytes,h=l[o++]|l[o++]<<8|l[o++]<<16|l[o++]<<24,g=l[o++]|l[o++]<<8|l[o++]<<16|l[o++]<<24,m=l[o++]|l[o++]<<8|l[o++]<<16|l[o++]<<24,b=l[o++]|l[o++]<<8|l[o++]<<16|l[o++]<<24;o=0,({low:new q(h,g),high:new q(m,b)}).high.lessThan(q.ZERO)&&a.push("-");let c=b>>26&31;if(c>>3==3)if(30===c)return a.join("")+"Infinity";else{if(31===c)return"NaN";t=b>>15&16383,e=8+(b>>14&1)}else e=b>>14&7,t=b>>17&16383;let d=t-6176;if(u.parts[0]=(16383&b)+((15&e)<<14),u.parts[1]=m,u.parts[2]=g,u.parts[3]=h,0===u.parts[0]&&0===u.parts[1]&&0===u.parts[2]&&0===u.parts[3])f=!0;else for(i=3;i>=0;i--){let t=0,e=function(t){let e=q.fromNumber(1e9),r=q.fromNumber(0);if(!t.parts[0]&&!t.parts[1]&&!t.parts[2]&&!t.parts[3])return{quotient:t,rem:r};for(let i=0;i<=3;i++)r=(r=r.shiftLeft(32)).add(new q(t.parts[i],0)),t.parts[i]=r.div(e).low,r=r.modulo(e);return{quotient:t,rem:r}}(u);if(u=e.quotient,t=e.rem.low)for(r=8;r>=0;r--)s[9*i+r]=t%10,t=Math.floor(t/10)}if(f)n=1,s[o]=0;else for(n=36;!s[o];)n-=1,o+=1;let p=n-1+d;if(p>=34||p<=-7||d>0){if(n>34)return a.push("0"),d>0?a.push(`E+${d}`):d<0&&a.push(`E${d}`),a.join("");a.push(`${s[o++]}`),(n-=1)&&a.push(".");for(let t=0;t<n;t++)a.push(`${s[o++]}`);a.push("E"),p>0?a.push(`+${p}`):a.push(`${p}`)}else if(d>=0)for(let t=0;t<n;t++)a.push(`${s[o++]}`);else{let t=n+d;if(t>0)for(let e=0;e<t;e++)a.push(`${s[o++]}`);else a.push("0");for(a.push(".");t++<0;)a.push("0");for(let e=0;e<n-Math.max(t-1,0);e++)a.push(`${s[o++]}`)}return a.join("")}toJSON(){return{$numberDecimal:this.toString()}}toExtendedJSON(){return{$numberDecimal:this.toString()}}static fromExtendedJSON(t){return te.fromString(t.$numberDecimal)}inspect(t,e,r){let i=(r??=m)(this.toString(),e);return`new Decimal128(${i})`}}class tr extends _{get _bsontype(){return"Double"}constructor(t){super(),t instanceof Number&&(t=t.valueOf()),this.value=+t}static fromString(t){let e=Number(t);if("NaN"===t)return new tr(NaN);if("Infinity"===t)return new tr(1/0);if("-Infinity"===t)return new tr(-1/0);if(!Number.isFinite(e))throw new d(`Input: ${t} is not representable as a Double`);if(t.trim()!==t)throw new d(`Input: '${t}' contains whitespace`);if(""===t)throw new d("Input is an empty string");if(/[^-0-9.+eE]/.test(t))throw new d(`Input: '${t}' is not in decimal or exponential notation`);return new tr(e)}valueOf(){return this.value}toJSON(){return this.value}toString(t){return this.value.toString(t)}toExtendedJSON(t){return t&&(t.legacy||t.relaxed&&isFinite(this.value))?this.value:Object.is(Math.sign(this.value),-0)?{$numberDouble:"-0.0"}:{$numberDouble:Number.isInteger(this.value)?this.value.toFixed(1):this.value.toString()}}static fromExtendedJSON(t,e){let r=parseFloat(t.$numberDouble);return e&&e.relaxed?r:new tr(r)}inspect(t,e,r){return r??=m,`new Double(${r(this.value,e)})`}}class ti extends _{get _bsontype(){return"Int32"}constructor(t){super(),t instanceof Number&&(t=t.valueOf()),this.value=0|t}static fromString(t){let e=F(t),r=Number(t);if(0x7fffffff<r)throw new d(`Input: '${t}' is larger than the maximum value for Int32`);if(-0x80000000>r)throw new d(`Input: '${t}' is smaller than the minimum value for Int32`);if(Number.isSafeInteger(r)){if(r.toString()!==e)throw new d(`Input: '${t}' is not a valid Int32 string`)}else throw new d(`Input: '${t}' is not a safe integer`);return new ti(r)}valueOf(){return this.value}toString(t){return this.value.toString(t)}toJSON(){return this.value}toExtendedJSON(t){return t&&(t.relaxed||t.legacy)?this.value:{$numberInt:this.value.toString()}}static fromExtendedJSON(t,e){return e&&e.relaxed?parseInt(t.$numberInt,10):new ti(t.$numberInt)}inspect(t,e,r){return r??=m,`new Int32(${r(this.value,e)})`}}class tn extends _{get _bsontype(){return"MaxKey"}toExtendedJSON(){return{$maxKey:1}}static fromExtendedJSON(){return new tn}inspect(){return"new MaxKey()"}}class ts extends _{get _bsontype(){return"MinKey"}toExtendedJSON(){return{$minKey:1}}static fromExtendedJSON(){return new ts}inspect(){return"new MinKey()"}}let to=null,tf=new WeakMap;class tu extends _{get _bsontype(){return"ObjectId"}constructor(t){let e;if(super(),"object"==typeof t&&t&&"id"in t){if("string"!=typeof t.id&&!ArrayBuffer.isView(t.id))throw new d("Argument passed in must have an id that is of type string or Buffer");e="toHexString"in t&&"function"==typeof t.toHexString?I.fromHex(t.toHexString()):t.id}else e=t;if(null==e||"number"==typeof e)this.buffer=tu.generate("number"==typeof e?e:void 0);else if(ArrayBuffer.isView(e)&&12===e.byteLength)this.buffer=I.toLocalBufferType(e);else if("string"==typeof e)if(tu.validateHexString(e))this.buffer=I.fromHex(e),tu.cacheHexString&&tf.set(this,e);else throw new d("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");else throw new d("Argument passed in does not match the accepted types")}get id(){return this.buffer}set id(t){this.buffer=t,tu.cacheHexString&&tf.set(this,I.toHex(t))}static validateHexString(t){if(t?.length!==24)return!1;for(let e=0;e<24;e++){let r=t.charCodeAt(e);if((!(r>=48)||!(r<=57))&&(!(r>=97)||!(r<=102))&&(!(r>=65)||!(r<=70)))return!1}return!0}toHexString(){if(tu.cacheHexString){let t=tf.get(this);if(t)return t}let t=I.toHex(this.id);return tu.cacheHexString&&tf.set(this,t),t}static getInc(){return tu.index=(tu.index+1)%0xffffff}static generate(t){"number"!=typeof t&&(t=Math.floor(Date.now()/1e3));let e=tu.getInc(),r=I.allocateUnsafe(12);return L.setInt32BE(r,0,t),null===to&&(to=I.randomBytes(5)),r[4]=to[0],r[5]=to[1],r[6]=to[2],r[7]=to[3],r[8]=to[4],r[11]=255&e,r[10]=e>>8&255,r[9]=e>>16&255,r}toString(t){return"base64"===t?I.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}static is(t){return null!=t&&"object"==typeof t&&"_bsontype"in t&&"ObjectId"===t._bsontype}equals(t){if(null==t)return!1;if(tu.is(t))return this.buffer[11]===t.buffer[11]&&I.equals(this.buffer,t.buffer);if("string"==typeof t)return t.toLowerCase()===this.toHexString();if("object"==typeof t&&"function"==typeof t.toHexString){let e=t.toHexString(),r=this.toHexString();return"string"==typeof e&&e.toLowerCase()===r}return!1}getTimestamp(){let t=new Date,e=L.getUint32BE(this.buffer,0);return t.setTime(1e3*Math.floor(e)),t}static createPk(){return new tu}serializeInto(t,e){return t[e]=this.buffer[0],t[e+1]=this.buffer[1],t[e+2]=this.buffer[2],t[e+3]=this.buffer[3],t[e+4]=this.buffer[4],t[e+5]=this.buffer[5],t[e+6]=this.buffer[6],t[e+7]=this.buffer[7],t[e+8]=this.buffer[8],t[e+9]=this.buffer[9],t[e+10]=this.buffer[10],t[e+11]=this.buffer[11],12}static createFromTime(t){let e=I.allocate(12);for(let t=11;t>=4;t--)e[t]=0;return L.setInt32BE(e,0,t),new tu(e)}static createFromHexString(t){if(t?.length!==24)throw new d("hex string must be 24 characters");return new tu(I.fromHex(t))}static createFromBase64(t){if(t?.length!==16)throw new d("base64 string must be 16 characters");return new tu(I.fromBase64(t))}static isValid(t){if(null==t)return!1;if("string"==typeof t)return tu.validateHexString(t);try{return new tu(t),!0}catch{return!1}}toExtendedJSON(){return this.toHexString?{$oid:this.toHexString()}:{$oid:this.toString("hex")}}static fromExtendedJSON(t){return new tu(t.$oid)}isCached(){return tu.cacheHexString&&tf.has(this)}inspect(t,e,r){return r??=m,`new ObjectId(${r(this.toHexString(),e)})`}}tu.index=Math.floor(0xffffff*Math.random());class ta extends _{get _bsontype(){return"BSONRegExp"}constructor(t,e){if(super(),this.pattern=t,this.options=(e??"").split("").sort().join(""),-1!==this.pattern.indexOf("\0"))throw new d(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);if(-1!==this.options.indexOf("\0"))throw new d(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);for(let t=0;t<this.options.length;t++)if("i"!==this.options[t]&&"m"!==this.options[t]&&"x"!==this.options[t]&&"l"!==this.options[t]&&"s"!==this.options[t]&&"u"!==this.options[t])throw new d(`The regular expression option [${this.options[t]}] is not supported`)}static parseOptions(t){return t?t.split("").sort().join(""):""}toExtendedJSON(t){return(t=t||{}).legacy?{$regex:this.pattern,$options:this.options}:{$regularExpression:{pattern:this.pattern,options:this.options}}}static fromExtendedJSON(t){if("$regex"in t){if("string"==typeof t.$regex)return new ta(t.$regex,ta.parseOptions(t.$options));else if("BSONRegExp"===t.$regex._bsontype)return t}if("$regularExpression"in t)return new ta(t.$regularExpression.pattern,ta.parseOptions(t.$regularExpression.options));throw new d(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(t)}`)}inspect(t,e,r){let i=function(t){if(null!=t&&"object"==typeof t&&"stylize"in t&&"function"==typeof t.stylize)return t.stylize}(e)??(t=>t),n=i((r??=m)(this.pattern),"regexp"),s=i(r(this.options),"regexp");return`new BSONRegExp(${n}, ${s})`}}class tl extends _{get _bsontype(){return"BSONSymbol"}constructor(t){super(),this.value=t}valueOf(){return this.value}toString(){return this.value}toJSON(){return this.value}toExtendedJSON(){return{$symbol:this.value}}static fromExtendedJSON(t){return new tl(t.$symbol)}inspect(t,e,r){return r??=m,`new BSONSymbol(${r(this.value,e)})`}}let th=q;class tg extends th{get _bsontype(){return"Timestamp"}get i(){return this.low>>>0}get t(){return this.high>>>0}constructor(t){if(null==t)super(0,0,!0);else if("bigint"==typeof t)super(t,!0);else if(q.isLong(t))super(t.low,t.high,!0);else if("object"==typeof t&&"t"in t&&"i"in t){if("number"!=typeof t.t&&("object"!=typeof t.t||"Int32"!==t.t._bsontype))throw new d("Timestamp constructed from { t, i } must provide t as a number");if("number"!=typeof t.i&&("object"!=typeof t.i||"Int32"!==t.i._bsontype))throw new d("Timestamp constructed from { t, i } must provide i as a number");let e=Number(t.t),r=Number(t.i);if(e<0||Number.isNaN(e))throw new d("Timestamp constructed from { t, i } must provide a positive t");if(r<0||Number.isNaN(r))throw new d("Timestamp constructed from { t, i } must provide a positive i");if(e>0xffffffff)throw new d("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");if(r>0xffffffff)throw new d("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");super(r,e,!0)}else throw new d("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }")}toJSON(){return{$timestamp:this.toString()}}static fromInt(t){return new tg(q.fromInt(t,!0))}static fromNumber(t){return new tg(q.fromNumber(t,!0))}static fromBits(t,e){return new tg({i:t,t:e})}static fromString(t,e){return new tg(q.fromString(t,!0,e))}toExtendedJSON(){return{$timestamp:{t:this.t,i:this.i}}}static fromExtendedJSON(t){let e=q.isLong(t.$timestamp.i)?t.$timestamp.i.getLowBitsUnsigned():t.$timestamp.i;return new tg({t:q.isLong(t.$timestamp.t)?t.$timestamp.t.getLowBitsUnsigned():t.$timestamp.t,i:e})}inspect(t,e,r){let i=(r??=m)(this.t,e),n=r(this.i,e);return`new Timestamp({ t: ${i}, i: ${n} })`}}tg.MAX_VALUE=q.MAX_UNSIGNED_VALUE;q.fromNumber(0x20000000000000),q.fromNumber(-0x20000000000000);let tm={$oid:tu,$binary:A,$uuid:A,$symbol:tl,$numberInt:ti,$numberDecimal:te,$numberDouble:tr,$numberLong:q,$minKey:ts,$maxKey:tn,$regex:ta,$regularExpression:ta,$timestamp:tg};function tb(t){let e=t.toISOString();return 0!==t.getUTCMilliseconds()?e:e.slice(0,-5)+"Z"}let tc={Binary:t=>new A(t.value(),t.sub_type),Code:t=>new C(t.code,t.scope),DBRef:t=>new J(t.collection||t.namespace,t.oid,t.db,t.fields),Decimal128:t=>new te(t.bytes),Double:t=>new tr(t.value),Int32:t=>new ti(t.value),Long:t=>q.fromBits(null!=t.low?t.low:t.low_,null!=t.low?t.high:t.high_,null!=t.low?t.unsigned:t.unsigned_),MaxKey:()=>new tn,MinKey:()=>new ts,ObjectId:t=>new tu(t),BSONRegExp:t=>new ta(t.pattern,t.options),BSONSymbol:t=>new tl(t.value),Timestamp:t=>tg.fromBits(t.low,t.high)};function td(t,e){let r={useBigInt64:e?.useBigInt64??!1,relaxed:e?.relaxed??!0,legacy:e?.legacy??!1};return JSON.parse(t,(t,e)=>{if(-1!==t.indexOf("\0"))throw new d(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(t)}`);return function t(e,r={}){if("number"==typeof e){let t=e<=0x7fffffff&&e>=-0x80000000,i=e<=c&&e>=-0x8000000000000000;if(r.relaxed||r.legacy)return e;if(Number.isInteger(e)&&!Object.is(e,-0)){if(t)return new ti(e);if(i)return r.useBigInt64?BigInt(e):q.fromNumber(e)}return new tr(e)}if(null==e||"object"!=typeof e)return e;if(e.$undefined)return null;let i=Object.keys(e).filter(t=>t.startsWith("$")&&null!=e[t]);for(let t=0;t<i.length;t++){let n=tm[i[t]];if(n)return n.fromExtendedJSON(e,r)}if(null!=e.$date){let t=e.$date,i=new Date;if(r.legacy)if("number"==typeof t)i.setTime(t);else if("string"==typeof t)i.setTime(Date.parse(t));else if("bigint"==typeof t)i.setTime(Number(t));else throw new y(`Unrecognized type for EJSON date: ${typeof t}`);else if("string"==typeof t)i.setTime(Date.parse(t));else if(q.isLong(t))i.setTime(t.toNumber());else if("number"==typeof t&&r.relaxed)i.setTime(t);else if("bigint"==typeof t)i.setTime(Number(t));else throw new y(`Unrecognized type for EJSON date: ${typeof t}`);return i}if(null!=e.$code){let r=Object.assign({},e);return e.$scope&&(r.$scope=t(e.$scope)),C.fromExtendedJSON(e)}if(P(e)||e.$dbPointer){let t=e.$ref?e:e.$dbPointer;if(t instanceof J)return t;let r=Object.keys(t).filter(t=>t.startsWith("$")),i=!0;if(r.forEach(t=>{-1===["$ref","$id","$db"].indexOf(t)&&(i=!1)}),i)return J.fromExtendedJSON(t)}return e}(e,r)})}function tp(t,e,r,i){return null!=r&&"object"==typeof r&&(i=r,r=0),null==e||"object"!=typeof e||Array.isArray(e)||(i=e,e=void 0,r=0),JSON.stringify(function t(e,r){if(e instanceof Map||h(e)){let i=Object.create(null);for(let[t,r]of e){if("string"!=typeof t)throw new d("Can only serialize maps with string keys");i[t]=r}return t(i,r)}if(("object"==typeof e||"function"==typeof e)&&null!==e){let t=r.seenObjects.findIndex(t=>t.obj===e);if(-1!==t){let e=r.seenObjects.map(t=>t.propertyName),i=e.slice(0,t).map(t=>`${t} -> `).join(""),n=e[t],s=" -> "+e.slice(t+1,e.length-1).map(t=>`${t} -> `).join(""),o=e[e.length-1],f=" ".repeat(i.length+n.length/2),u="-".repeat(s.length+(n.length+o.length)/2-1);throw new d(`Converting circular structure to EJSON:
    ${i}${n}${s}${o}
    ${f}\\${u}/`)}r.seenObjects[r.seenObjects.length-1].obj=e}if(Array.isArray(e))return e.map((e,i)=>{r.seenObjects.push({propertyName:`index ${i}`,obj:null});try{return t(e,r)}finally{r.seenObjects.pop()}});if(void 0===e)return null;if(e instanceof Date||g(e)){let t=e.getTime(),i=t>-1&&t<2534023188e5;return r.legacy?r.relaxed&&i?{$date:e.getTime()}:{$date:tb(e)}:r.relaxed&&i?{$date:tb(e)}:{$date:{$numberLong:e.getTime().toString()}}}if("number"==typeof e&&(!r.relaxed||!isFinite(e))){if(Number.isInteger(e)&&!Object.is(e,-0)){if(e>=-0x80000000&&e<=0x7fffffff)return{$numberInt:e.toString()};if(e>=-0x8000000000000000&&e<=c)return{$numberLong:e.toString()}}return{$numberDouble:Object.is(e,-0)?"-0.0":e.toString()}}if("bigint"==typeof e)return r.relaxed?Number(BigInt.asIntN(64,e)):{$numberLong:BigInt.asIntN(64,e).toString()};if(e instanceof RegExp||l(e)){let t=e.flags;if(void 0===t){let r=e.toString().match(/[gimuy]*$/);r&&(t=r[0])}return new ta(e.source,t).toExtendedJSON(r)}return null!=e&&"object"==typeof e?function(e,r){if(null==e||"object"!=typeof e)throw new d("not an object instance");let i=e._bsontype;if(void 0===i){let i={};for(let n of Object.keys(e)){r.seenObjects.push({propertyName:n,obj:null});try{let s=t(e[n],r);"__proto__"===n?Object.defineProperty(i,n,{value:s,writable:!0,enumerable:!0,configurable:!0}):i[n]=s}finally{r.seenObjects.pop()}}return i}if(null!=e&&"object"==typeof e&&"string"==typeof e._bsontype&&6!==e[b])throw new p;if(null!=e&&"object"==typeof e&&"_bsontype"in e&&"string"==typeof e._bsontype){let n=e;if("function"!=typeof n.toExtendedJSON){let t=tc[e._bsontype];if(!t)throw new d("Unrecognized or invalid _bsontype: "+e._bsontype);n=t(n)}return"Code"===i&&n.scope?n=new C(n.code,t(n.scope,r)):"DBRef"===i&&n.oid&&(n=new J(t(n.collection,r),t(n.oid,r),t(n.db,r),t(n.fields,r))),n.toExtendedJSON(r)}throw new d("_bsontype must be a string, but was: "+typeof i)}(e,r):e}(t,Object.assign({relaxed:!0,legacy:!1},i,{seenObjects:[{propertyName:"(root)",obj:null}]})),e,r)}let ty=Object.create(null);ty.parse=td,ty.stringify=tp,ty.serialize=function(t,e){return JSON.parse(tp(t,e=e||{}))},ty.deserialize=function(t,e){return e=e||{},td(JSON.stringify(t),e)},Object.freeze(ty);let tw={double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:255,maxKey:127};function tS(t,e){try{return L.getNonnegativeInt32LE(t,e)}catch(t){throw new w("BSON size cannot be negative",e,{cause:t})}}function tx(t,e){let r=e;for(;0!==t[r];r++);if(r===t.length-1)throw new w("Null terminator not found",e);return r}let tN=Object.create(null);tN.parseToElements=function(t,e=0){if(e??=0,t.length<5)throw new w(`Input must be at least 5 bytes, got ${t.length} bytes`,e);let r=tS(t,e);if(r>t.length-e)throw new w(`Parsed documentSize (${r} bytes) does not match input length (${t.length} bytes)`,e);if(0!==t[e+r-1])throw new w("BSON documents must end in 0x00",e+r);let i=[],n=e+4;for(;n<=r+e;){let s,o=t[n];if(n+=1,0===o){if(n-e!==r)throw new w("Invalid 0x00 type byte",n);break}let f=n,u=tx(t,n)-f;if(n+=u+1,o===tw.double||o===tw.long||o===tw.date||o===tw.timestamp)s=8;else if(o===tw.int)s=4;else if(o===tw.objectId)s=12;else if(o===tw.decimal)s=16;else if(o===tw.bool)s=1;else if(o===tw.null||o===tw.undefined||o===tw.maxKey||o===tw.minKey)s=0;else if(o===tw.regex)s=tx(t,tx(t,n)+1)+1-n;else if(o===tw.object||o===tw.array||o===tw.javascriptWithScope)s=tS(t,n);else if(o===tw.string||o===tw.binData||o===tw.dbPointer||o===tw.javascript||o===tw.symbol)s=tS(t,n)+4,o===tw.binData&&(s+=1),o===tw.dbPointer&&(s+=12);else throw new w(`Invalid 0x${o.toString(16).padStart(2,"0")} type byte`,n);if(s>r)throw new w("value reports length larger than document",n);i.push([o,f,u,n,s]),n+=s}return i},tN.ByteUtils=I,tN.NumberUtils=L,Object.freeze(tN),I.allocate(0x1100000)}}]);